#!/usr/bin/env perl 
use warnings;
use strict;

$ENV{'PROPHET_REPO'} = $ENV{'SD_REPO'} || $ENV{'HOME'}.'/.sd';

use Prophet::CLI;
use App::SD::Model::Ticket;
my $cli = Prophet::CLI->new( { app_class => 'App::SD' } );
$cli->run_one_command;


package App::SD::CLI::Command;
use base qw/Prophet::CLI::Command/;
use Path::Class;

sub get_content {
    my $self = shift;
    my $type = shift;

    my $content;
    if (my $file = file(delete $self->args->{'file'})) {
        $content = $file->slurp();
        $self->args->{'name'} = $file->basename;
    } elsif ($content = delete $self->args->{'content'}) {

    } elsif (exists $self->args->{'edit'}) {
        $content = $self->edit_text('');
    } else {
        print "Please type your $type and press ctrl-d.\n";
        $content = do { local $/; <> };
    }

    chomp $content;
    return $content;
}

package App::SD::CLI::Command::Ticket::Comment;
use base qw/App::SD::CLI::Command::Ticket/;

use constant record_class => 'App::SD::Model::Comment';

package App::SD::CLI::Command::Ticket::Comment::Create;
use base qw/App::SD::CLI::Command::Ticket::Comment Prophet::CLI::Command::Create/;

sub run {
    my $self = shift;
    $self->args->{'ticket'} = $self->uuid;
    $self->args->{'content'} = $self->get_content('comment');
    $self->SUPER::run(@_);
}
# override args to feed in that ticket's uuid as an argument to the comment



package App::SD::CLI::Command::Attachment;
use base qw/App::SD::CLI::Command/;
use constant record_class => 'App::SD::Model::Attachment';

package App::SD::CLI::Command::Attachment::Create;
use base qw/App::SD::CLI::Command::Attachment Prophet::CLI::Command::Create/;

sub run {
    my $self = shift;

    $self->args->{'content'} = $self->get_content('attachment');

    $self->SUPER::run(@_);

}

package App::SD::CLI::Command::Ticket::Attachment::Create;
use base qw/App::SD::CLI::Command::Attachment::Create/;
# override args to feed in that ticket's uuid as an argument to the comment
#


sub run {
    my $self = shift;
    $self->args->{'ticket'} = $self->uuid;
    $self->SUPER::run(@_);
}


package App::SD::CLI::Command::Ticket::Attachment::Search;
use base qw/App::SD::CLI::Command::Attachment Prophet::CLI::Command::Search/;
# override args to feed in that ticket's uuid as an argument to the comment


sub type {'attachment'}
sub get_search_callback {
    my $self = shift;
    return sub {
        shift->prop('ticket') eq $self->uuid ? 1 : 0;
        }

}


package App::SD::CLI::Command::Attachment::Content;
use base qw/App::SD::CLI::Command::Attachment App::SD::CLI::Command Prophet::CLI::Command::Show/;

sub run {
    my $self = shift;
    my $record =  $self->_get_record;
    $record->load(uuid => $self->cli->uuid);
    print $record->prop('content');
}

package App::SD::CLI::Command::Help;
use base qw/App::SD::CLI::Command/;

sub run {

print <<EOF

$0 ticket create --summary "This is a summary" --status new --somekey value
$0 ticket update --uuid <uuid> --status resolved
$0 ticket search --regex .
$0 ticket delete --uuid <uuid>
$0 ticket show --uuid <uuid>
$0 pull --from remote-url

$0 help  
    Show this file

EOF

}

package App::SD::CLI::Command::Ticket::Show;
use base qw/App::SD::CLI::Command Prophet::CLI::Command::Show/;

package App::SD::CLI::Command::Details;
use base qw/App::SD::CLI::Command/;
sub run {
    my $self = shift;
    print "\n=head1 METADATA\n\n"; 
    $self->App::SD::CLI::Command::Ticket::Show::run();
    print "\n=head1 ATTACHMENTS\n\n";
    use Clone;
    my $foo = Clone::clone($self);
    $foo->type('attachment');
    bless $foo, 'App::SD::CLI::Command::Ticket::Attachment::Search';
    $foo->run;
    print "\n=head1 COMMENTS\n\n";
    my $bar = Clone::clone($self);
    bless $bar, 'App::SD::CLI::Command::Ticket::Comments';
    $bar->type('comment');
    $bar->App::SD::CLI::Command::Ticket::Comments::run();
}

package App::SD::CLI::Command::Ticket;
use base qw/App::SD::CLI::Command/;

use constant record_class => 'App::SD::Model::Ticket';

package App::SD::CLI::Command::Ticket::Comments;
use base qw/App::SD::CLI::Command::Ticket/;

sub run {
    my $self = shift;
    my $record = App::SD::Model::Ticket->new( handle => $self->cli->app_handle->handle);
    $record->load( uuid => $self->uuid );
    unless (@{$record->comments}) {
        print "No comments found\n";
    }

    for (@{$record->comments}) {
        print "comment id: ".$_->uuid."\n";
        print "Content:\n".$_->prop('content')."\n";
    }

}


package App::SD::CLI::Command::Merge;
use base qw/App::SD::CLI::Command Prophet::CLI::Command::Merge/;

package App::SD::CLI::Command::Push;
use base qw/App::SD::CLI::Command::Merge/;

sub run {
    my $self = shift; 
    local $ENV{PROPHET_RESOLVER} = 'Prompt';
    bless $self, 'App::SD::CLI::Command::Merge';
    $self->args( {to => $self->args->{'to'}, from => $self->app_handle->default_replica_type.":file://".$self->app_handle->handle->fs_root });
    $self->run; 
}

package App::SD::CLI::Command::Pull;
use base qw/App::SD::CLI::Command::Merge/;

sub run {
    my $self = shift; 

    die "Please specify a --from.\n" if !defined($self->args->{'from'});

    local $ENV{PROPHET_RESOLVER} = 'Prompt';
    bless $self, 'App::SD::CLI::Command::Merge';
    $self->args({  from => $self->args->{'from'}, 
                   to => $self->cli->app_handle->default_replica_type.":file://".$cli->app_handle->handle->fs_root });
    $self->run; 
}

